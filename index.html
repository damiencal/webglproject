<html><head>
<title>SpaceShip</title>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">

<link href="vendor/bootstrap.min.css" rel="stylesheet">
<link href="vendor/material.min.css" rel="stylesheet">

<script type="text/javascript" src="gl-matrix.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="game-utils.js"></script>
<script type="text/javascript" src="fbo.js"></script>
<script type="text/javascript" src="heightfield.js"></script>
<script type="text/javascript" src="background.js"></script>
<script type="text/javascript" src="spaceship.js"></script>
<script type="text/javascript" src="vendor/jquery.min.js"></script>
<script type="text/javascript" src="vendor/bootstrap.min.js"></script>
<script type="text/javascript" src="vendor/material.min.js"></script>
<script type="text/javascript" src="enemy.js"></script>
<script type="text/javascript" src="shoot.js"></script>

<script id="heightfield-vs" type="x-shader/x-vertex">
    // *** le vertex shader ***
    attribute vec3 aVertexPosition; // la position du sommet
    attribute vec2 aVertexCoord; // sa coordonnee de texture

    varying vec2 vTextureCoord; // on souhaite rasteriser la coordonnee

    void main(void) {
        // projection de la position
        gl_Position = vec4(aVertexPosition, 1.0);

        // stockage de la coordonnee de texture
        vTextureCoord = aVertexCoord;
    }
</script>

<script id="heightfield-fs" type="x-shader/x-fragment">
// *** le fragment shader ***
precision highp float; // precision des nombres flottant

uniform vec2 uOffset;
uniform float uAmplitude; // amplitude du bruit
uniform float uFrequency; // frequence du bruit
uniform float uPersistence; // persistence du bruit

varying vec2 vTextureCoord; // recuperation de la coord rasterisee

float hash(vec2 p) {
    // pseudo random fonction
    float h = dot(mod(p,vec2(100.0)),vec2(127.1,311.7));
    return -1.0 + 2.0*fract(sin(h)*43758.5453123);
}

float vnoise(in vec2 p) {
    // genere une valeur random sur une position sp√©cifique d'une grille
    // pris sur shadertoy
    vec2 i = floor(p);
    vec2 f = fract(p);

    vec2 u = f*f*(3.0-2.0*f);

    return mix( mix( hash( i + vec2(0.0,0.0) ),
                     hash( i + vec2(1.0,0.0) ), u.x),
                mix( hash( i + vec2(0.0,1.0) ),
                     hash( i + vec2(1.0,1.0) ), u.x), u.y);
}

float fractalNoise(in vec2 p) {
    const int nb = 5; // nb octave
    float f = uFrequency; // frequency
    float a = uAmplitude; // amplitude
    float e = uPersistence; // persistence

    float n = 0.0;
    for(int i=0;i<nb;++i) {
        n = n + a*vnoise(p*f);
        f = 2.0*f;
        a = a*e;
    }
    return n;
}

void main(void) {
    vec2 p = vTextureCoord*2.0-vec2(1.0); // coordonnees
    float n = fractalNoise(p+uOffset)*0.5+0.5; // bruit

    gl_FragColor = vec4(vec3(n),1.0);

}
</script>

<script id="background-vs" type="x-shader/x-vertex">
    // *** le vertex shader ***
    attribute vec3 aVertexPosition; // la position du sommet
    attribute vec2 aVertexCoord; // sa coordonnee de texture

    varying vec2 vTextureCoord; // on souhaite rasteriser la coordonnee

    void main(void) {
        // projection de la position
        gl_Position = vec4(aVertexPosition, 1.0);

        // stockage de la coordonnee de texture
        vTextureCoord = aVertexCoord;
    }
</script>

<script id="background-fs" type="x-shader/x-fragment">
// *** le fragment shader ***
precision highp float; // precision des nombres flottant

uniform sampler2D uHeightfield; // la texture de hauteurs
uniform vec2 uTextureSize; // la taille de la texture
varying vec2 vTextureCoord; // recuperation de la coord rasterisee

vec3 shade(in vec3 n,in float d) {
    vec2 xy = vTextureCoord.xy*2.0-vec2(1.0);
    vec3 v = -normalize(vec3(xy.x,xy.y,1.0)); // vecteur vue
    vec3 l = normalize(vec3(-0.3,0.0,1.0)); // vecteur lumi√®re (pourrait varier au cours du temps pour de meilleurs effets)

    // TODO : le shading !
    // la fonction prend en entr√©e la normale du terrain et sa profondeur

    return n;
}

vec3 computeNormal() {
    const float scale = 20.0;

    vec2 ps = 1.0/uTextureSize;
    float xp = texture2D(uHeightfield,vTextureCoord+vec2( ps.x,0.0)).x;
    float xm = texture2D(uHeightfield,vTextureCoord+vec2(-ps.x,0.0)).x;
    float yp = texture2D(uHeightfield,vTextureCoord+vec2(0.0, ps.y)).x;
    float ym = texture2D(uHeightfield,vTextureCoord+vec2(0.0,-ps.y)).x;

    float gx = 0.5*(xp-xm)*scale;
    float gy = 0.5*(yp-ym)*scale;

    vec3 v1 = normalize(vec3(1.0,0.0,gx));
    vec3 v2 = normalize(vec3(0.0,1.0,gy));

    return cross(v1,v2);
}

void main(void) {
    float d = texture2D(uHeightfield,vTextureCoord).x;
    vec3 n = computeNormal();
    vec3 s = shade(n,d);
    gl_FragColor = vec4(s,1.0);

}
</script>

<script id="spaceship-vs" type="x-shader/x-vertex">
    // *** le vertex shader ***
    attribute vec3 aVertexPosition; // la position du sommet
    attribute vec2 aVertexCoord; // sa coordonnee de texture

    uniform vec2 uPosition; // position du vaisseau
    varying vec2 vTextureCoord; // on souhaite rasteriser la coordonnee

    void main(void) {
        // projection de la position
        gl_Position = vec4(aVertexPosition+vec3(uPosition,0.0), 1.0);

        // stockage de la coordonnee de texture
        vTextureCoord = aVertexCoord;
    }
</script>
<script id="spaceship-fs" type="x-shader/x-fragment">
// *** le fragment shader ***
precision highp float; // precision des nombres flottant

varying vec2 vTextureCoord; // recuperation de la coord rasterisee

uniform sampler2D uMaTexture; // la texture en entree

void main(void) {
    gl_FragColor = texture2D(uMaTexture,vTextureCoord);

}
</script>

<script id="enemy-vs" type="x-shader/x-vertex">
    // *** le vertex shader ***
    attribute vec3 aVertexPosition; // la position du sommet
    attribute vec2 aVertexCoord; // sa coordonnee de texture

    uniform vec2 uPosition; // position du vaisseau
    varying vec2 vTextureCoord; // on souhaite rasteriser la coordonnee

    void main(void) {
        // projection de la position
        gl_Position = vec4(aVertexPosition+vec3(uPosition,0.0), 1.0);

        // stockage de la coordonnee de texture
        vTextureCoord = aVertexCoord;
    }
</script>
<script id="enemy-fs" type="x-shader/x-fragment">
// *** le fragment shader ***
precision highp float; // precision des nombres flottant

varying vec2 vTextureCoord; // recuperation de la coord rasterisee

uniform sampler2D uMaTextureEnemy; // la texture en entree

void main(void) {
    gl_FragColor = texture2D(uMaTextureEnemy,vTextureCoord);

}
</script>

<script id="shoot-vs" type="x-shader/x-vertex">
    // *** le vertex shader ***
    attribute vec3 aVertexPosition; // la position du sommet
    attribute vec2 aVertexCoord; // sa coordonnee de texture

    uniform vec2 uPosition; // position du tir
    varying vec2 vTextureCoord; // on souhaite rasteriser la coordonnee

    void main(void) {
        // projection de la position
        gl_Position = vec4(aVertexPosition+vec3(uPosition,0.0), 1.0);

        // stockage de la coordonnee de texture
        vTextureCoord = aVertexCoord;
    }
</script>
<script id="shoot-fs" type="x-shader/x-fragment">
    // *** le fragment shader ***
    precision highp float; // precision des nombres flottant

    varying vec2 vTextureCoord; // recuperation de la coord rasterisee

    uniform sampler2D uMaTextureShoot; // la texture en entree

    void main(void) {
        gl_FragColor = texture2D(uMaTextureShoot,vTextureCoord);
    }
</script>

<script type="text/javascript">

    // Objets graphiques
    var fbo; // le FBO utilis√© pour rendre la texture de hauteur
    var heightfield; // l'objet heightfield, sa g√©om√©trie, son shader
    var background; // l'objet background, sa g√©om√©trie, son shader
    var spaceship; // l'objet spaceship, sa g√©om√©trie, son shader
    var enemies = new Array();      // Tableau qui contient les objets Vaisseau
    var missiles = new Array();     // Tableau qui contient les objets missile

    // Constantes pour les vaisseaux ennemis
    var NOMBRE_ENNEMIS = 11;        // Nombre d'ennemis dans le niveau
    var VITESSE_VAISSEAUX = 0.003;  // Vitesse des vaisseaux ennemis

    var lateralVariation = 0.0;

    // Constantes pour le spaceship
    var DEPLACEMENTS_LATERAL_VAISSEAU = 0.03; // Vitesse de deplacement du vaisseau
    var MAX_RANGE_LEFT_VAISSEAU = -0.9; // Limite ‡ gauche de l'Ècran du vaisseau
    var MAX_RANGE_RIGHT_VAISSEAU = 0.9; // Limite ‡ droite de l'Ècran du vaisseau
    var MAX_RANGE_BOTTOM_VAISSEAU = -0.6; // Limite en bas de l'Ècran du vaisseau

    // Gestion des missiles
    var VITESSE_MISSILE = 0.02;
    var missilesPosition = [];

    // Variable pour gÈrer la pression sur la touche de tir
    var keyAlreadyPressed = "inactive";

    // Variable pour jouer les sons
    var audio = new Audio();


    function drawScene() {
        // initialisation du viewport
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        // efface les buffers de couleur et de profondeur
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // active le FBO (a partie de la, on dessine dans la texture associ√©e)
        gl.bindFramebuffer(gl.FRAMEBUFFER,fbo.id());

        // dessin du heightfield
        gl.useProgram(heightfield.shader());
        heightfield.sendUniformVariables();
        heightfield.draw();

        // desactivation du FBO (on dessine sur l'ecran maintenant)
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // dessin du background (utilise la texture dessin√©e pr√©c√©demment)
        gl.useProgram(background.shader());
        background.sendUniformVariables();
        background.draw();

        gl.enable(gl.BLEND); //Activation de gl.Blend

        // dessin du vaisseau (shader par defaut ici)
        gl.useProgram(spaceship.shader());
        spaceship.sendUniformVariables();
        spaceship.draw();

        // dessin des vaisseaux ennemis (shader par defaut ici)
        for (var i=0; i<enemies.length; i++)
        {
            gl.useProgram(enemies[i].shader());
            enemies[i].sendUniformVariables();
            enemies[i].draw();
        }

        // Attribution des coordonnÈes de chaque missiles
        for (var i=0; i<missiles.length; i++){
            missiles[i].setPosition(missilesPosition[0,i][0], missilesPosition[0,i][1]);
        }
        // Dessin de tous les missiles
        for (var i=0; i<missiles.length;i++){
            gl.useProgram(shoot.shader());
            missiles[i].sendUniformVariables();
            missiles[i].draw();
        }


        gl.disable(gl.BLEND);
    }

    // une bonne mani√®re de gerer les evenements claviers
    // permet d'avoir plusieurs touches appuy√©es simultan√©men
    var currentlyPressedKeys = {};

    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;
    }


    function handleKeyUp(event) {
        // Tir d'un missile
        if (event.keyCode == 17)
            keyAlreadyPressed = "relache";

        currentlyPressedKeys[event.keyCode] = false;
    }

    /************************************************************
    ********** Gestion des Interactions *************************
    ************************************************************/
    function handleKeys() {
        if (currentlyPressedKeys[33]) {
            // Page Up (par exemple)
            // faire quelque chose...
        }
        // Tir d'un missile
        if (currentlyPressedKeys[17]) {
            if (keyAlreadyPressed == "inactive")
            {
                missiles.push(new Shoot);   // Ajout d'un missiles ‡ la liste des missiles
                missilesPosition.push([spaceship.position[0], spaceship.position[1]]);
                audio.src="sounds/shoot.wav";
                audio.play();
                keyAlreadyPressed = "active";
            }
            else if (keyAlreadyPressed == "relache")
                keyAlreadyPressed = "inactive";

        }
        // ** Deplacement gauche du vaisseau **
        if (currentlyPressedKeys[37]) {
            var newx = spaceship.position[0]-DEPLACEMENTS_LATERAL_VAISSEAU;
            if (newx < MAX_RANGE_LEFT_VAISSEAU){
                newx = MAX_RANGE_LEFT_VAISSEAU;
            }
            var newy = MAX_RANGE_BOTTOM_VAISSEAU;
            spaceship.setPosition(newx, newy);
        }
        // ** Deplacement droit du vaisseau **
        if (currentlyPressedKeys[39]) {
            var newx = spaceship.position[0]+DEPLACEMENTS_LATERAL_VAISSEAU;
            if (newx > MAX_RANGE_RIGHT_VAISSEAU){
                newx = MAX_RANGE_RIGHT_VAISSEAU;
            }
            var newy = MAX_RANGE_BOTTOM_VAISSEAU;
            spaceship.setPosition(newx, newy);
        }
    }

    function mouseMove(event) {
        // controle de la position du vaisseau en fonction de la souris
        // la position est remapp√©e entre -1 et 1 pour cela
        var newx = 2.0*(event.clientX/gl.viewportWidth)-1.0;
        var newy = -(2.0*(event.clientY/gl.viewportHeight)-1.0);
        spaceship.setPosition(newx,newy);
    }


    // animation
    var lastTime = 0;
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            // chaque objet est susceptible de s'animer
            var elapsed = timeNow - lastTime;
            heightfield.setParameters(elapsed);
            spaceship.setParameters(elapsed);
            background.setParameters(elapsed);

            // On applique setParameters aux vaissaux
            for (var i=0; i<enemies.length; i++)
                enemies[i].setParameters(elapsed);
        }
        lastTime = timeNow;
    }

    function tick() {
        requestAnimFrame(tick);
        handleKeys();


        // *** Gestion Deplacements Missiles ***
        for (var i=0; i<missiles.length;i++){
            //console.log("OLD_POSITION_"+missilesPosition[0,i]);
            var oldx = missilesPosition[0,i][0];
            var oldy = missilesPosition[0,i][1];
            var newx = oldx;
            var newy = oldy + VITESSE_MISSILE;
            if (newy > 1.1){
                // On detruit le le missile, dans l'idÈal Object + index liste
                if (i > -1) {
                    missilesPosition.splice(i, 1);
                    missiles.splice(i, 1);
                }
            }else{
                missilesPosition[0,i][0] = newx;
                missilesPosition[0,i][1] = newy;
            }
            //console.log("NEW_POSITION_**"+missilesPosition[0,i]);
        }

        animateEnemies();
        destroyEnemies();

        drawScene();
        animate();
    }


    function webGLStart() {
        // initialisation du canvas et des objets OpenGL
        var canvas = document.getElementById("SpaceShip");
        initGL(canvas);

        // init FBO
        fbo = new FBO(canvas.width,canvas.height,1,false);

        // init de tous les shaders
        initHeightfieldShader();
        initBackgroundShader();
        initSpaceshipShader();
        initEnemyShader();
        initShootShader();

        // init de tous les objets
        heightfield = new Heightfield();
        background = new Background(fbo.texture(0));
        spaceship = new Spaceship();
        shoot = new Shoot();

        for (var i=0; i<20; i++)
            createEnnemies();

        //colisionhandler object
        var colisionHandler = new ColisionHandler();

        // la couleur de fond sera noire
        //gl.clearColor(0.0, 1.0, 0.0, 1.0);

        // active le teste de profondeur
        gl.enable(gl.DEPTH_TEST);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); //Active la transparance

        /* Mouse and keyboard interaction functions */
        //canvas.addEventListener('mousedown', tbMouseDown, true);
        //canvas.addEventListener('mousemove', mouseMove, true);
        //canvas.addEventListener('mouseup', tbMouseUp, true);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        // dessine la scene
        tick();
    }

    function createEnnemies ()
    {
        enemies.push(new Enemy);
        var indice = enemies.length;    // indice du vaisseau dans le tableau des vaisseaux

        // Random de la positionX du vaisseau jusqu'‡ avoir une coordonÈes comprise entre 0 et 0.895
        var random = 1;
        while ( 0.895 < random ) // bornesEcran-tailleVaisseau == 1-0.105 Donc gÈnÈration d'une position entre [-0.895 , 0.895]
            random = Math.random();
        if (parseInt(random*100)%2 == 1)
            random = -random;   // La position doit Ítre comprise entre -1 et 1. Donc qd random est pair x=0.5; sinon x= -0.5

        enemies[indice-1].x = random;  // PositionX
        if (indice == 1)
            enemies[indice-1].y = 1.3;  // PositionY du premier vaisseau
        else
            enemies[indice-1].y = enemies[indice-2].y + 0.3;  // PositionY du vaisseau dernier vaisseau, 0.003 au dessus du prÈcÈdent
    }

    // Anime les ennemis (positionX & positionY) et les dÈtruits si besoin
    function animateEnemies ()
    {
        for (var i=0; i<enemies.length; i++)
        {
            var curantEnemy = enemies[i];
            // Positions initiales
            //console.log("Vaisseau "+i+" : Position [" +curantEnemy.x+ ";" +curantEnemy.y );

            // Variation latÈral des vaisseaux (de la positionX)
            if ( lateralVariation < 2000 )
            {
                if ( 1000 < lateralVariation )
                {
                    if (-0.895< curantEnemy.x)
                        curantEnemy.x -= 0.005;
                    lateralVariation++;
                }
                else
                {
                    if (curantEnemy.x < 0.895)
                        curantEnemy.x += 0.005;
                    lateralVariation++;
                }
            }
            else
                lateralVariation = 0;

             // Calcule de la positionY finale du vaisseau
            curantEnemy.y = curantEnemy.y - VITESSE_VAISSEAUX;

             // Assignation du la nouvelle position au vaisseau
            curantEnemy.setPosition(curantEnemy.x, curantEnemy.y);
             //console.log("Point "+i +" ajustÈ");
        }
    }


    /////////// Fonction qui gËre la destruction des vaisseaux ennemi ///////////
    // 1. Cas d'un vaisseau ennemi qui n'a pas Ètait dÈtruit et qui arrive au bout
    // 2. Cas d'une colision entre un vaisseau ennemi et le spaceship
    /////////////////////////////// Fin Algo ///////////////////////////////////

    function destroyEnemies()
    {
        for (var i=0; i<enemies.length; i++)
        {
            // 1. Cas d'un vaisseau ennemi qui n'a pas Ètait dÈtruit et qui arrive au bout
            colisionBordEcran (i, enemies[i]);
            // 2. Cas d'une colision entre un vaisseau ennemi et le spaceship
            colisionSpaceship(i, enemies[i]);
        }
    }


    // Fonction qui dÈtecte si le vaisseau passÈ en paramËtre entre en colision avec le spaceship principal
    // Si tel est le cas : On affiche l'explosion puis on remove le vaisseau plus tard
    function colisionSpaceship (index, curantEnemy)
    {
        // On considËre la forme du carrÈ
        //  X1;Y2---------X2;Y2
        //    |             |
        //    |             |
        //  X1;Y1---------X2;Y1
        //
        // Constante qui dÈfini le stade d'explosion du vaisseau
        var INTERVALLES_EXPLOSION_BORD = new Array(0.0, 0.01, 0.03, 0.05);
        // Constante de la taille des carrÈs liÈs ‡ la taille de l'image
        var LARGEUR_CARRE = 0.19;
        var HAUTEUR_CARRE = 0.19;

        // DÈfinition des angles du carrÈ Spaceship
        var spaceshipX1 = spaceship.position[0]-LARGEUR_CARRE;
        var spaceshipX2 = spaceship.position[0];
        var spaceshipY1 = spaceship.position[1];
        var spaceshipY2 = spaceship.position[1]+HAUTEUR_CARRE;

        // DÈfinition des angles du carrÈ Enemy
        var enemyX1 = curantEnemy.x-LARGEUR_CARRE;
        var enemyX2 = curantEnemy.x;
        var enemyY1 = curantEnemy.y;
        var enemyY2 = curantEnemy.y+HAUTEUR_CARRE;

        //Colision du vaisseau avec le spaceship (explosion du vaisseau)

        // Si le vaisseau rentre en colision avec le spaceship
        idImage = INTERVALLES_EXPLOSION_BORD.length;
        var exploding=false;
        for (k=0; k<INTERVALLES_EXPLOSION_BORD.length; k++)
        {
            intervalleK = INTERVALLES_EXPLOSION_BORD[k];
            // On charge l'image qui correspond ‡ son stade d'explosion
            if (((spaceshipX1 < enemyX2+intervalleK && spaceshipX1 > enemyX1-intervalleK) ||
            (spaceshipX2 < enemyX2+intervalleK && spaceshipX2 > enemyX1-intervalleK))
            &&
           ((spaceshipY1 < enemyY2+intervalleK && spaceshipY1 > enemyY1-intervalleK) ||
            (spaceshipY2 < enemyY2+intervalleK && spaceshipY2 > enemyY1-intervalleK)))
            {
                if (k==0)   // Si le vaisseau
                    enemies.splice(index, 1);   // On dÈtruit l'objet vaisseau
                curantEnemy.setImage("exploding"+idImage+".png"); // On actualise l'image de l'objet vaisseau
                break;

            }
            idImage--;
        }

        // Si un vaisseau est en train d'exploser, on joue le son
        if (exploding)
        {

        }
    }

    // Fonction qui dÈtecte si le vaisseau passÈ en paramËtre entre en colision avec le bord infÈrieur de l'Ècran
    // Si tel est le cas : On affiche l'explosion puis on remove le vaisseau plus tard
    function colisionBordEcran (index, curantEnemy)
    {
        // Constante qui dÈfini le stade d'explosion du vaisseau
        var INTERVALLES_EXPLOSION = new Array(0.825, 0.815, 0.800, 0.785, 0.770);

        // 1.2 Colision du vaisseau avec le bord infÈrieur de l'Ècran (explosion du vaisseau)
        // Si le vaisseau doit exploser
        if (curantEnemy.y < -(INTERVALLES_EXPLOSION[INTERVALLES_EXPLOSION.length-1]))
        {
            // Si un vaisseau est en train d'exploser, on joue le son
            audio.src="sounds/explosion.wav";
            audio.play();

            // On charge l'image qui correspond ‡ son stade d'explosion
            var idImage = INTERVALLES_EXPLOSION.length; // Trick pour Èviter de recharger les images prÈcÈdentes
            for (j=0; j<INTERVALLES_EXPLOSION.length; j++)
            {
                if (curantEnemy.y < -(INTERVALLES_EXPLOSION[j]))
                {
                    if (j==0)
                        enemies.splice(index, 1);   // On dÈtruit l'objet vaisseau
                    curantEnemy.setImage("exploding"+idImage+".png"); // On actualise l'image de l'objet vaisseau
                    break;
                }
                idImage--;
            }
        }
    }

    function colisionTir ()
    {

    }


</script>


</head>


<body onload="webGLStart();">
        <header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="../" class="navbar-brand">Stargate</a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse">
      <ul class="nav navbar-nav">
        <li>
          <a id="muteLink" href="#" onclick="webGLStart()">New Game</a>
        </li>
        <li>
          <a id="muteLink" href="#">Score</a>
        </li>
        <li>
          <a id="muteLink" href="#">Life</a>
        </li>
        <li>
          <a id="muteLink" href="#">Power</a>
        </li>
        <li>
          <a id="muteLink" href="#" onclick="toggleMute()">Mute</a>
        </li>
      </ul>
    </nav>
  </div>
</header>

    <canvas id="SpaceShip" style="border: none;" width="800" height="800"></canvas>

</body>
    <script>
            $(document).ready(function() {
                // This command is used to initialize some elements and make them work properly
                $.material.init();
            });
    </script>
    <script>
                function toggleMute() {
                mute();
                document.getElementById("muteLink").innerText = sounds.mute ? "unmute" : "mute";
            }
    </script>
</html>
